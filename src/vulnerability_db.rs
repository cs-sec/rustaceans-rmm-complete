use actix_web::{web, App, HttpResponse, HttpServer, Result as ActixResult};
use serde::{Deserialize, Serialize};
use serde_json;
use std::collections::HashMap;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityRecord {
    pub cve_id: String,
    pub severity: String,
    pub description: String,
    pub affected_packages: Vec<String>,
    pub affected_versions: Vec<String>,
    pub fixed_versions: Vec<String>,
    pub published_date: DateTime<Utc>,
    pub patch_available: bool,
    pub patch_source: Option<String>, // chocolatey, apt, yum, etc.
    pub patch_command: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageInfo {
    pub name: String,
    pub current_version: String,
    pub latest_version: String,
    pub package_manager: String, // chocolatey, apt, yum, winget
    pub vulnerabilities: Vec<VulnerabilityRecord>,
    pub security_updates_available: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PatchRecommendation {
    pub package_name: String,
    pub current_version: String,
    pub target_version: String,
    pub vulnerability_count: usize,
    pub severity_level: String,
    pub update_command: String,
    pub requires_reboot: bool,
    pub estimated_downtime: Option<String>,
}

pub struct VulnerabilityDatabase {
    // In production, this would connect to actual vulnerability databases
    cve_database: HashMap<String, VulnerabilityRecord>,
    pub package_database: HashMap<String, PackageInfo>,
}

impl VulnerabilityDatabase {
    pub fn new() -> Self {
        let mut db = Self {
            cve_database: HashMap::new(),
            package_database: HashMap::new(),
        };
        db.initialize_database();
        db
    }

    fn initialize_database(&mut self) {
        // Real vulnerability data - this would be populated from NIST NVD, MITRE, etc.
        
        // Chrome vulnerabilities
        let chrome_vuln = VulnerabilityRecord {
            cve_id: "CVE-2024-0517".to_string(),
            severity: "High".to_string(),
            description: "Out of bounds write in V8 in Google Chrome prior to 121.0.6167.85".to_string(),
            affected_packages: vec!["google-chrome".to_string(), "chromium".to_string()],
            affected_versions: vec!["< 121.0.6167.85".to_string()],
            fixed_versions: vec!["121.0.6167.85".to_string(), "121.0.6167.139".to_string()],
            published_date: Utc::now(),
            patch_available: true,
            patch_source: Some("chocolatey".to_string()),
            patch_command: Some("choco upgrade googlechrome -y".to_string()),
        };

        // Firefox vulnerabilities
        let firefox_vuln = VulnerabilityRecord {
            cve_id: "CVE-2024-0741".to_string(),
            severity: "Critical".to_string(),
            description: "Out of bounds write in ANGLE in Firefox before 122.0".to_string(),
            affected_packages: vec!["firefox".to_string(), "mozilla-firefox".to_string()],
            affected_versions: vec!["< 122.0".to_string()],
            fixed_versions: vec!["122.0".to_string(), "122.0.1".to_string()],
            published_date: Utc::now(),
            patch_available: true,
            patch_source: Some("chocolatey".to_string()),
            patch_command: Some("choco upgrade firefox -y".to_string()),
        };

        // OpenSSL vulnerabilities
        let openssl_vuln = VulnerabilityRecord {
            cve_id: "CVE-2023-5678".to_string(),
            severity: "High".to_string(),
            description: "Generating excessively long X9.42 DH keys or checking excessively long X9.42 DH keys or parameters may be very slow".to_string(),
            affected_packages: vec!["openssl".to_string(), "libssl-dev".to_string()],
            affected_versions: vec!["< 3.0.12".to_string(), "< 1.1.1w".to_string()],
            fixed_versions: vec!["3.0.12".to_string(), "1.1.1w".to_string()],
            published_date: Utc::now(),
            patch_available: true,
            patch_source: Some("apt".to_string()),
            patch_command: Some("sudo apt update && sudo apt upgrade openssl -y".to_string()),
        };

        // Windows vulnerabilities
        let windows_vuln = VulnerabilityRecord {
            cve_id: "CVE-2024-21334".to_string(),
            severity: "Critical".to_string(),
            description: "Windows Authentication Elevation of Privilege Vulnerability".to_string(),
            affected_packages: vec!["windows".to_string(), "microsoft-windows".to_string()],
            affected_versions: vec!["Windows 10", "Windows 11", "Windows Server 2019", "Windows Server 2022"].iter().map(|s| s.to_string()).collect(),
            fixed_versions: vec!["KB5034441".to_string()],
            published_date: Utc::now(),
            patch_available: true,
            patch_source: Some("windows-update".to_string()),
            patch_command: Some("Install-WindowsUpdate -AcceptAll -AutoReboot".to_string()),
        };

        self.cve_database.insert(chrome_vuln.cve_id.clone(), chrome_vuln);
        self.cve_database.insert(firefox_vuln.cve_id.clone(), firefox_vuln);
        self.cve_database.insert(openssl_vuln.cve_id.clone(), openssl_vuln);
        self.cve_database.insert(windows_vuln.cve_id.clone(), windows_vuln);

        // Package information with vulnerability mappings
        let chrome_package = PackageInfo {
            name: "google-chrome".to_string(),
            current_version: "120.0.6099.199".to_string(),
            latest_version: "121.0.6167.139".to_string(),
            package_manager: "chocolatey".to_string(),
            vulnerabilities: vec![self.cve_database.get("CVE-2024-0517").unwrap().clone()],
            security_updates_available: true,
        };

        let firefox_package = PackageInfo {
            name: "firefox".to_string(),
            current_version: "121.0".to_string(),
            latest_version: "122.0.1".to_string(),
            package_manager: "chocolatey".to_string(),
            vulnerabilities: vec![self.cve_database.get("CVE-2024-0741").unwrap().clone()],
            security_updates_available: true,
        };

        let openssl_package = PackageInfo {
            name: "openssl".to_string(),
            current_version: "3.0.11".to_string(),
            latest_version: "3.0.12".to_string(),
            package_manager: "apt".to_string(),
            vulnerabilities: vec![self.cve_database.get("CVE-2023-5678").unwrap().clone()],
            security_updates_available: true,
        };

        self.package_database.insert(chrome_package.name.clone(), chrome_package);
        self.package_database.insert(firefox_package.name.clone(), firefox_package);
        self.package_database.insert(openssl_package.name.clone(), openssl_package);
    }

    pub fn check_vulnerabilities(&self, package_name: &str, version: &str) -> Vec<VulnerabilityRecord> {
        if let Some(package_info) = self.package_database.get(package_name) {
            package_info.vulnerabilities.iter()
                .filter(|vuln| self.is_version_vulnerable(version, &vuln.affected_versions))
                .cloned()
                .collect()
        } else {
            Vec::new()
        }
    }

    pub fn get_patch_recommendations(&self, installed_packages: &[(&str, &str)]) -> Vec<PatchRecommendation> {
        let mut recommendations = Vec::new();

        for (package_name, current_version) in installed_packages {
            if let Some(package_info) = self.package_database.get(*package_name) {
                let vulnerabilities = self.check_vulnerabilities(package_name, current_version);
                
                if !vulnerabilities.is_empty() {
                    let severity = if vulnerabilities.iter().any(|v| v.severity == "Critical") {
                        "Critical"
                    } else if vulnerabilities.iter().any(|v| v.severity == "High") {
                        "High"
                    } else {
                        "Medium"
                    };

                    let update_command = match package_info.package_manager.as_str() {
                        "chocolatey" => format!("choco upgrade {} -y", package_name),
                        "apt" => format!("sudo apt update && sudo apt upgrade {} -y", package_name),
                        "yum" => format!("sudo yum update {} -y", package_name),
                        "winget" => format!("winget upgrade {}", package_name),
                        "windows-update" => "Install-WindowsUpdate -AcceptAll -AutoReboot".to_string(),
                        _ => format!("Update {} manually", package_name),
                    };

                    let requires_reboot = package_name.contains("windows") || 
                                        package_name.contains("kernel") ||
                                        package_name.contains("driver");

                    recommendations.push(PatchRecommendation {
                        package_name: package_name.to_string(),
                        current_version: current_version.to_string(),
                        target_version: package_info.latest_version.clone(),
                        vulnerability_count: vulnerabilities.len(),
                        severity_level: severity.to_string(),
                        update_command,
                        requires_reboot,
                        estimated_downtime: if requires_reboot { 
                            Some("5-10 minutes".to_string()) 
                        } else { 
                            None 
                        },
                    });
                }
            }
        }

        // Sort by severity and vulnerability count
        recommendations.sort_by(|a, b| {
            let severity_order = |s: &str| match s {
                "Critical" => 0,
                "High" => 1,
                "Medium" => 2,
                _ => 3,
            };
            
            let severity_cmp = severity_order(&a.severity_level).cmp(&severity_order(&b.severity_level));
            if severity_cmp == std::cmp::Ordering::Equal {
                b.vulnerability_count.cmp(&a.vulnerability_count)
            } else {
                severity_cmp
            }
        });

        recommendations
    }

    fn is_version_vulnerable(&self, current_version: &str, affected_versions: &[String]) -> bool {
        // Simplified version comparison - in production would use proper semver parsing
        for affected_range in affected_versions {
            if affected_range.starts_with("< ") {
                let target_version = affected_range.trim_start_matches("< ");
                return self.version_less_than(current_version, target_version);
            }
        }
        false
    }

    fn version_less_than(&self, version1: &str, version2: &str) -> bool {
        // Simplified version comparison - in production would use proper semver
        let v1_parts: Vec<u32> = version1.split('.').filter_map(|s| s.parse().ok()).collect();
        let v2_parts: Vec<u32> = version2.split('.').filter_map(|s| s.parse().ok()).collect();
        
        for i in 0..std::cmp::max(v1_parts.len(), v2_parts.len()) {
            let v1_part = v1_parts.get(i).unwrap_or(&0);
            let v2_part = v2_parts.get(i).unwrap_or(&0);
            
            if v1_part < v2_part {
                return true;
            } else if v1_part > v2_part {
                return false;
            }
        }
        false
    }

    pub fn get_package_info(&self, package_name: &str) -> Option<&PackageInfo> {
        self.package_database.get(package_name)
    }
}

// API endpoints for vulnerability database integration
async fn get_vulnerability_report() -> ActixResult<HttpResponse> {
    let db = VulnerabilityDatabase::new();
    
    // Simulate installed packages from a client system
    let installed_packages = vec![
        ("google-chrome", "120.0.6099.199"),
        ("firefox", "121.0"),
        ("openssl", "3.0.11"),
    ];

    let recommendations = db.get_patch_recommendations(&installed_packages);
    
    let report = serde_json::json!({
        "scan_timestamp": Utc::now().to_rfc3339(),
        "total_packages_scanned": installed_packages.len(),
        "vulnerabilities_found": recommendations.iter().map(|r| r.vulnerability_count).sum::<usize>(),
        "critical_patches": recommendations.iter().filter(|r| r.severity_level == "Critical").count(),
        "high_priority_patches": recommendations.iter().filter(|r| r.severity_level == "High").count(),
        "patch_recommendations": recommendations
    });

    Ok(HttpResponse::Ok().json(report))
}

async fn get_package_vulnerabilities(path: web::Path<String>) -> ActixResult<HttpResponse> {
    let package_name = path.into_inner();
    let db = VulnerabilityDatabase::new();
    
    if let Some(package_info) = db.package_database.get(&package_name) {
        Ok(HttpResponse::Ok().json(package_info))
    } else {
        Ok(HttpResponse::NotFound().json(serde_json::json!({
            "error": "Package not found in vulnerability database"
        })))
    }
}

async fn get_patch_commands() -> ActixResult<HttpResponse> {
    let commands = serde_json::json!({
        "windows": {
            "chocolatey": {
                "install": "Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))",
                "update_all": "choco upgrade all -y",
                "update_specific": "choco upgrade {package_name} -y"
            },
            "winget": {
                "update_all": "winget upgrade --all",
                "update_specific": "winget upgrade {package_name}"
            },
            "windows_update": "Install-WindowsUpdate -AcceptAll -AutoReboot"
        },
        "linux": {
            "apt": {
                "update_all": "sudo apt update && sudo apt upgrade -y",
                "update_specific": "sudo apt update && sudo apt upgrade {package_name} -y",
                "security_only": "sudo apt update && sudo apt upgrade -y --only-upgrade"
            },
            "yum": {
                "update_all": "sudo yum update -y",
                "update_specific": "sudo yum update {package_name} -y",
                "security_only": "sudo yum update --security -y"
            }
        }
    });

    Ok(HttpResponse::Ok().json(commands))
}